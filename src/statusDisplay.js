const fs = require('fs').promises;\nconst path = require('path');\nconst { execSync } = require('child_process');\n\n// --- Configuration (Could be passed as args or read from env if needed) ---\n// Assuming standard paths based on installation\nconst APP_NAME = 'google-photos-backup';\nconst DATA_DIR = `/var/lib/${APP_NAME}`;\nconst STATUS_FILENAME = 'status.json'; \nconst SERVICE_NAME = `${APP_NAME}.service`;\nconst TIMER_NAME = `${APP_NAME}.timer`;\nconst statusFilePath = path.join(DATA_DIR, STATUS_FILENAME);\n\n// --- Helper Functions ---\n\n// Use standard ANSI escape codes for colors\nfunction echoBlue(text) { console.log(`\x1b[34m${text}\x1b[0m`); }\nfunction echoRed(text) { console.log(`\x1b[31m${text}\x1b[0m`); }\nfunction echoYellow(text) { console.log(`\x1b[33m${text}\x1b[0m`); }\n\nfunction executeCommand(command) {\n    try {\n        // Execute command synchronously, inherit stdio for direct output/errors if needed\n        // Use a timeout to prevent hanging\n        const output = execSync(command, { encoding: 'utf8', stdio: 'pipe', timeout: 5000 }); \n        return { success: true, output: output.trim() };\n    } catch (error) {\n        // error.stderr might contain useful info from the command\n        // error.stdout might also have partial output\n        // error.status is the exit code\n        return {\n            success: false, \n            error: error.message, \n            stderr: error.stderr?.toString().trim(),\n            stdout: error.stdout?.toString().trim(),\n            status: error.status\n        };\n    }\n}\n\nfunction parseSystemctlOutput(output) {\n    const statusInfo = { state: 'unknown', substate: 'unknown', loaded: 'unknown', nextRun: null };\n    if (!output) return statusInfo;\n\n    // Use \s* for whitespace flexibility\n    const loadedMatch = output.match(/^\s*Loaded:\s*([^\(]+)/m);\n    if (loadedMatch) statusInfo.loaded = loadedMatch[1].trim();\n\n    // Match state and substate more carefully\n    const activeMatch = output.match(/^\s*Active:\s*([^\s]+)\s+\(([^\)]+)\)/m);\n    if (activeMatch) {\n        statusInfo.state = activeMatch[1].trim();\n        statusInfo.substate = activeMatch[2].trim();\n    }\n    \n    // For timers, look for Trigger or Next elapse\n    const triggerMatch = output.match(/^\s*Trigger:\s*(.*)$/m);\n    if (triggerMatch) {\n        statusInfo.nextRun = triggerMatch[1].trim();\n    } else {\n        const nextElapseMatch = output.match(/^\s*Next elapse:\s*(.*)$/m);\n        if (nextElapseMatch) {\n            statusInfo.nextRun = nextElapseMatch[1].trim();\n        }\n    }\n    \n    // Simplify state if it includes 'failed'\n    if (statusInfo.state.includes('failed')) {\n         statusInfo.state = 'failed';\n    }\n\n    return statusInfo;\n}\n\nfunction formatTimestamp(isoTimestamp) {\n    if (!isoTimestamp || isoTimestamp === 'Never' || isoTimestamp === 'N/A') {\n        return isoTimestamp;\n    }\n    try {\n        const date = new Date(isoTimestamp);\n        return date.toLocaleString(); // Uses system locale for formatting\n    } catch (e) {\n        return isoTimestamp; // Return original if parsing fails\n    }\n}\n\n// --- Main Logic ---\nasync function displayStatus() {\n    let statusData = null;\n    let appStatusReadError = null;\n\n    echoBlue("--- Google Photos Backup Status ---\");\n\n    // 1. Read Application Status File\n    try {\n        const content = await fs.readFile(statusFilePath, 'utf8');\n        statusData = JSON.parse(content);\n    } catch (error) {\n        if (error.code === 'ENOENT') {\n            appStatusReadError = `Status file not found: ${statusFilePath}`;\n        } else {\n            appStatusReadError = `Error reading status file ${statusFilePath}: ${error.message}`;\n        }\n        echoYellow(`    Warning: ${appStatusReadError}`);\n    }\n\n    // Display App Status\n    const currentAppState = statusData?.status || (appStatusReadError ? 'Error' : 'Unknown');\n    const lastSyncTime = formatTimestamp(statusData?.lastSyncTimestamp || 'Never');\n    const lastFinishTime = formatTimestamp(statusData?.lastRunFinish || 'N/A');\n    const lastOutcome = statusData?.lastRunOutcome || 'N/A';\n    const lastDownloaded = statusData?.lastRunItemsDownloaded ?? 'N/A'; // Use nullish coalescing\n    const lastError = statusData?.lastRunError || 'None';\n\n    console.log(` Application State: ${currentAppState}`);\n    console.log(` Last Sync Success: ${lastSyncTime}`);\n    console.log(` Last Run Finished: ${lastFinishTime}`);\n    console.log(` Last Run Outcome:  ${lastOutcome}`);\n    console.log(` Last Run Stats:    Downloaded ${lastDownloaded} items.`);\n    if (lastError && lastError !== 'None') {\n        echoRed(`  Last Run Error:    ${lastError}`);\n    }\n\n    // 2. Get Systemd Service Status\n    const serviceResult = executeCommand(`systemctl status ${SERVICE_NAME} --no-pager`);\n    let serviceStatusText = 'Error checking status';\n    if (serviceResult.success || serviceResult.status === 3) { // status 3 means inactive\n        const parsed = parseSystemctlOutput(serviceResult.output);\n        serviceStatusText = `${parsed.state} (${parsed.substate}) - Loaded: ${parsed.loaded}`;\n    } else {\n         serviceStatusText = `Error (${serviceResult.error || 'Unknown'})`\n         if(serviceResult.stderr) serviceStatusText += ` - ${serviceResult.stderr}`;\n    }\n    console.log(` Service State:     ${serviceStatusText}`);\n\n    // 3. Get Systemd Timer Status\n    // Check if timer unit exists before querying it\n    const timerCheckResult = executeCommand(`systemctl list-unit-files ${TIMER_NAME}`);\n    if (timerCheckResult.success && timerCheckResult.output.includes(TIMER_NAME)) {\n        const timerResult = executeCommand(`systemctl status ${TIMER_NAME} --no-pager`);\n        let timerStatusText = 'Error checking status';\n        let nextRunText = 'N/A';\n        if (timerResult.success || timerResult.status === 3) {\n            const parsed = parseSystemctlOutput(timerResult.output);\n            timerStatusText = `${parsed.state} (${parsed.substate})`;\n            nextRunText = parsed.nextRun || 'Scheduled (pending)';\n        } else {\n             timerStatusText = `Error (${timerResult.error || 'Unknown'})`\n             if(timerResult.stderr) timerStatusText += ` - ${timerResult.stderr}`;\n        }\n         console.log(` Timer State:       ${timerStatusText}`);\n         console.log(` Next Scheduled Run: ${nextRunText}`);\n    } else {\n        console.log(` Timer State:       N/A (Continuous Mode or Timer Not Installed)`);\n    }\n    \n    echoBlue("-------------------------------------\");\n    // Note: Suggesting the wrapper command, not this script directly\n    console.log(`(For detailed logs, run: ${APP_NAME} logs)`);\n}\n\n// Execute the function\ndisplayStatus().catch(err => {\n    echoRed("An unexpected error occurred during status display:");\n    console.error(err);\n    process.exitCode = 1; // Indicate failure\n}); 